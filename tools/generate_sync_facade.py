#!/usr/bin/env -S uv run --script
import argparse
import ast
import itertools
import subprocess
import textwrap
from pathlib import Path

HEADER = '''"""Auto-generated synchronous facade for `Api`.

Do not edit this file directly.

It is generated from `api.Api` by `tools/generate_sync.py`.
"""

import typing
from collections.abc import Generator
from enum import StrEnum
from typing import Any

import aiohttp
from whenever import Date, PlainDateTime, ZonedDateTime

from hassette.const.misc import FalseySentinel
from hassette.models.history import HistoryEntry
from hassette.models.services import ServiceResponse
from hassette.resources.base import Resource

if typing.TYPE_CHECKING:
    from hassette import Api, Hassette
    from hassette.events.hass.raw import HassStateDict
    from hassette.models.entities import EntityT
    from hassette.models.states.base import BaseState

'''


CLASS_HEADER = '''
class ApiSyncFacade(Resource):
    """Synchronous facade for the API service.

    This class provides synchronous methods that wrap the asynchronous methods of the Api class,
    allowing for blocking calls in a synchronous context.

    It is important to note that these methods should not be called from within an existing event loop,
    as they will raise a RuntimeError in such cases. Use the asynchronous methods directly when operating
    within an event loop.
    """

    _api: "Api"

    @classmethod
    def create(cls, hassette: "Hassette", api: "Api"):
        inst = cls(hassette, parent=api)
        inst._api = api
        inst.mark_ready(reason="Synchronous API facade initialized")
        return inst

'''


def is_overload(func: ast.AsyncFunctionDef) -> bool:
    """Return True if this function is an @overload stub."""
    for deco in func.decorator_list:
        if isinstance(deco, ast.Name) and deco.id == "overload":
            return True
        if isinstance(deco, ast.Attribute) and deco.attr == "overload":
            return True
    return False


def format_signature_and_call(func: ast.AsyncFunctionDef) -> tuple[str, str]:
    """Return (signature_source, call_arguments_source) for a function.

    - Signature includes `self` exactly as in the original.
    - Call string omits `self` and preserves positional, varargs, kwonly, and kwargs.
    """
    args = func.args

    parts: list[str] = []
    call_parts: list[str] = []

    # Positional-only + regular args
    total_pos = args.posonlyargs + args.args
    defaults = list(args.defaults)

    # Map defaults to the last N positional args
    defaults_map: dict[int, ast.expr] = {}
    if defaults:
        for arg, default in zip(total_pos[-len(defaults) :], defaults, strict=False):
            defaults_map[id(arg)] = default

    # Positional-only args
    for arg in args.posonlyargs:
        name = arg.arg
        annotation = f": {ast.unparse(arg.annotation)}" if arg.annotation else ""
        default = ""
        if id(arg) in defaults_map:
            default = f" = {ast.unparse(defaults_map[id(arg)])}"
        parts.append(f"{name}{annotation}{default}")
        call_parts.append(name)

    if args.posonlyargs:
        parts.append("/")

    # Regular positional args (includes self)
    for arg in args.args:
        name = arg.arg
        annotation = f": {ast.unparse(arg.annotation)}" if arg.annotation else ""
        default = ""
        if id(arg) in defaults_map:
            default = f" = {ast.unparse(defaults_map[id(arg)])}"
        parts.append(f"{name}{annotation}{default}")
        if name != "self":
            call_parts.append(name)

    # *vararg
    if args.vararg:
        name = args.vararg.arg
        annotation = f": {ast.unparse(args.vararg.annotation)}" if args.vararg.annotation else ""
        parts.append(f"*{name}{annotation}")
        call_parts.append(f"*{name}")

    # kwonly args
    if args.kwonlyargs:
        # If there was no *vararg we need a bare * to start kw-only section
        if not args.vararg:
            parts.append("*")

        for arg, default in itertools.zip_longest(args.kwonlyargs, args.kw_defaults):
            assert arg is not None
            name = arg.arg
            annotation = f": {ast.unparse(arg.annotation)}" if arg.annotation else ""
            if default is not None:
                parts.append(f"{name}{annotation} = {ast.unparse(default)}")
            else:
                parts.append(f"{name}{annotation}")
            call_parts.append(f"{name}={name}")

    # **kwargs
    if args.kwarg:
        name = args.kwarg.arg
        annotation = f": {ast.unparse(args.kwarg.annotation)}" if args.kwarg.annotation else ""
        parts.append(f"**{name}{annotation}")
        call_parts.append(f"**{name}")

    sig_str = ", ".join(parts)
    call_str = ", ".join(call_parts)
    return sig_str, call_str


def gen_wrapper(func: ast.AsyncFunctionDef) -> str:
    sig, call = format_signature_and_call(func)
    name = func.name
    returns = f" -> {ast.unparse(func.returns)}" if func.returns else ""

    doc = ast.get_docstring(func)
    if doc:
        doc_str = textwrap.indent('"""' + doc + '"""', " " * 8)
        doc_block = f"\n{doc_str}\n\n"
    else:
        doc_block = "\n"

    body = (
        f"    def {name}({sig}){returns}:{doc_block}"
        f"        return self.task_bucket.run_sync(self._api.{name}({call}))\n"
    )
    return body


def generate_sync(api_path: Path) -> str:
    source = api_path.read_text(encoding="utf8")
    module = ast.parse(source, filename=str(api_path))

    api_class: ast.ClassDef | None = None
    for node in module.body:
        if isinstance(node, ast.ClassDef) and node.name == "Api":
            api_class = node
            break

    if api_class is None:
        raise SystemExit("Could not find class `Api` in api.py")

    wrappers: list[str] = [
        gen_wrapper(node) for node in api_class.body if isinstance(node, ast.AsyncFunctionDef) and not is_overload(node)
    ]

    wrappers_str = "\n".join(wrappers)

    return HEADER + CLASS_HEADER + wrappers_str


def run_ruff(path: Path) -> None:
    # format
    subprocess.run(["ruff", "format", str(path)])

    # validate
    subprocess.run(["ruff", "check", str(path)], check=True)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate sync.py facade from api.py")
    parser.add_argument(
        "--api-path",
        type=Path,
        default=Path(__file__).resolve().parent.parent / "src" / "hassette" / "api" / "api.py",
        help="Path to api.py (default: hassette/api.py relative to repo root)",
    )
    parser.add_argument(
        "--out",
        type=Path,
        default=None,
        help="Output path for sync.py (default: alongside api.py as sync.py)",
    )

    args = parser.parse_args()
    api_path = args.api_path
    if not api_path.exists():
        raise SystemExit(f"api.py not found at {api_path}")

    out_path = args.out or api_path.with_name("sync.py")

    code = generate_sync(api_path)
    out_path.write_text(code, encoding="utf8")
    run_ruff(out_path)
    print(f"Wrote {out_path}")


if __name__ == "__main__":
    main()
